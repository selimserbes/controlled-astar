var searchIndex = new Map(JSON.parse('[\
["controlled_astar",{"doc":"","t":"EEEEEECCCFGPPPPNNNNNNNNNNNNNNNNNNNNGPFPPPPPPPNNNNNNNNNNNNNNNNNNNNONONNNNNNNNNNNNNNOOFFNNNNNNNONNNNNNNNNNNONNNNNNNN","n":["AStar","AStarError","Direction","Node","PriorityQueue","State","astar","node","priority_queue","AStar","AStarError","GoalNodeBlocked","NodeNotFound","PathNotFound","StartNodeBlocked","borrow","borrow","borrow_mut","borrow_mut","find_shortest_path","fmt","fmt","fmt","from","from","into","into","new","to_string","try_from","try_from","try_into","try_into","type_id","type_id","Direction","East","Node","North","NorthEast","NorthWest","South","SouthEast","SouthWest","West","borrow","borrow","borrow_mut","borrow_mut","clone","clone","clone_into","clone_into","cmp","eq","eq","fmt","fmt","from","from","get_directions","hash","hash","into","into","is_blocked","matrix_to_nodes","neighbors","new","partial_cmp","print_matrix","remove_neighbor","set_blocked","set_neighbor","to_owned","to_owned","try_from","try_from","try_into","try_into","type_id","type_id","x","y","PriorityQueue","State","borrow","borrow","borrow_mut","borrow_mut","clone","clone_into","cmp","cost","eq","fmt","fmt","from","from","into","into","is_empty","new","partial_cmp","pop","position","push","to_owned","try_from","try_from","try_into","try_into","type_id","type_id"],"q":[[0,"controlled_astar"],[9,"controlled_astar::astar"],[35,"controlled_astar::node"],[84,"controlled_astar::priority_queue"],[114,"alloc::vec"],[115,"core::option"],[116,"core::result"],[117,"core::fmt"],[118,"core::fmt"],[119,"alloc::string"],[120,"core::any"],[121,"core::cmp"],[122,"core::hash"]],"d":["","","","","","","","","","Structure implementing the A* algorithm.","Error types that can occur during A* pathfinding.","","","","","","","","","Finds the shortest path from start to goal using the A* …","Formats the error for debugging purposes.","Formats the error for display in user-facing contexts.","","Returns the argument unchanged.","Returns the argument unchanged.","Calls <code>U::from(self)</code>.","Calls <code>U::from(self)</code>.","Creates a new <code>AStar</code> instance with the provided nodes.","","","","","","","","Directions used in nodes.","","Represents a node on a map.","","","","","","","","","","","","","","","","","","","","","Returns the argument unchanged.","Returns the argument unchanged.","Returns a vector of directions where neighbors are present.","","","Calls <code>U::from(self)</code>.","Calls <code>U::from(self)</code>.","","Converts a 2D matrix into <code>Node</code> objects.","","Creates a new <code>Node</code> and initializes neighbors for the four …","","Prints a 2D matrix and an optional path to the screen.","Removes the neighbor for a specific direction.","Sets whether the node is blocked or not.","Sets the neighbor position for a specific direction.","","","","","","","","","","","Priority queue used in the A* algorithm.","Represents the states used in the A* algorithm.","","","","","","","Defines the ordering for <code>State</code>, ensuring that states with …","","","","","Returns the argument unchanged.","Returns the argument unchanged.","Calls <code>U::from(self)</code>.","Calls <code>U::from(self)</code>.","Checks if the queue is empty.","Creates a new, empty <code>PriorityQueue</code>.","Provides partial ordering for <code>State</code>.","Removes and returns the <code>State</code> with the highest priority …","","Adds a new <code>State</code> to the queue.","","","","","","",""],"i":[0,0,0,0,0,0,0,0,0,0,0,6,6,6,6,6,1,6,1,1,6,6,1,6,1,6,1,1,6,6,1,6,1,6,1,0,14,0,14,14,14,14,14,14,14,14,10,14,10,14,10,14,10,14,14,10,14,10,14,10,10,14,10,14,10,10,10,10,10,14,10,10,10,10,14,10,14,10,14,10,14,10,10,10,0,0,21,22,21,22,21,21,21,21,21,21,22,21,22,21,22,22,22,21,22,21,22,21,21,22,21,22,21,22],"f":"```````````````{ce{}{}}000{{b{f{dd}}{f{dd}}}{{n{{j{{h{{f{dd}}}}}}l}}}}{{lA`}Ab}0{{bA`}Ab}{cc{}}044{{{Af{{f{dd}}Ad}}}b}{cAh{}}{c{{n{e}}}{}{}}000{cAj{}}0``````````8888{AlAl}{AdAd}{{ce}An{}{}}0{{AlAl}B`}{{AlAl}Bb}{{AdAd}Bb}{{AlA`}Ab}{{AdA`}Ab}<<{Ad{{h{Al}}}}{{Alc}AnBd}{{Adc}AnBd}{ce{}{}}0`{{{Bh{{h{Bf}}}}}{{Af{{f{dd}}Ad}}}}`{{ddBbdd}Ad}{{AlAl}{{j{B`}}}}{{{Bh{{h{Bf}}}}{j{{h{{f{dd}}}}}}}An}{{AdAl}An}{{AdBb}An}{{AdAl{j{{f{dd}}}}}An}77{c{{n{e}}}{}{}}000{cAj{}}0````9999{BjBj}{{ce}An{}{}}{{BjBj}B`}`{{BjBj}Bb}{{BjA`}Ab}{{BlA`}Ab}{cc{}}0{ce{}{}}0{BlBb}{{}Bl}{{BjBj}{{j{B`}}}}{Bl{{j{Bj}}}}`{{BlBj}An}5>>>>==","c":[],"p":[[5,"AStar",9],[1,"usize"],[1,"tuple"],[5,"Vec",114],[6,"Option",115],[6,"AStarError",9],[6,"Result",116],[5,"Formatter",117],[8,"Result",117],[5,"Node",35],[5,"HashMap",118],[5,"String",119],[5,"TypeId",120],[6,"Direction",35],[1,"unit"],[6,"Ordering",121],[1,"bool"],[10,"Hasher",122],[1,"i32"],[1,"slice"],[5,"State",84],[5,"PriorityQueue",84]],"b":[[20,"impl-Debug-for-AStarError"],[21,"impl-Display-for-AStarError"]]}],\
["example",{"doc":"A* Pathfinding Example","t":"","n":[],"q":[],"d":[],"i":[],"f":"","c":[],"p":[],"b":[]}]\
]'));
if (typeof exports !== 'undefined') exports.searchIndex = searchIndex;
else if (window.initSearch) window.initSearch(searchIndex);
