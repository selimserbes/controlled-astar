var searchIndex = new Map(JSON.parse('[\
["controlled_astar",{"doc":"","t":"EEEEEECCCFGPPPPNNNNNNNNNNNNNNNNNNNNGPFPPPPPPPNNNNNNNNNNNNNNNNNNNNNOONNNNNNNNNNNNNNOOFFNNNNNNNONNNNNNNNNNNONNNNNNNN","n":["AStar","AStarError","Direction","Node","PriorityQueue","State","astar","node","priority_queue","AStar","AStarError","GoalNodeBlocked","NodeNotFound","PathNotFound","StartNodeBlocked","borrow","borrow","borrow_mut","borrow_mut","find_shortest_path","fmt","fmt","fmt","from","from","into","into","new","to_string","try_from","try_from","try_into","try_into","type_id","type_id","Direction","East","Node","North","NorthEast","NorthWest","South","SouthEast","SouthWest","West","borrow","borrow","borrow_mut","borrow_mut","clone","clone","clone_into","clone_into","cmp","eq","eq","fmt","fmt","from","from","get_directions","grid_to_nodes","hash","hash","into","into","is_blocked","neighbors","new","partial_cmp","print_grid","remove_neighbor","set_blocked","set_neighbor","to_owned","to_owned","try_from","try_from","try_into","try_into","type_id","type_id","x","y","PriorityQueue","State","borrow","borrow","borrow_mut","borrow_mut","clone","clone_into","cmp","cost","eq","fmt","fmt","from","from","into","into","is_empty","new","partial_cmp","pop","position","push","to_owned","try_from","try_from","try_into","try_into","type_id","type_id"],"q":[[0,"controlled_astar"],[9,"controlled_astar::astar"],[35,"controlled_astar::node"],[84,"controlled_astar::priority_queue"],[114,"alloc::vec"],[115,"core::option"],[116,"core::result"],[117,"core::fmt"],[118,"core::fmt"],[119,"alloc::string"],[120,"core::any"],[121,"core::cmp"],[122,"core::hash"]],"d":["","","","","","","","","","Structure implementing the A* algorithm.","Error types that can occur during A* pathfinding.","","","","","","","","","Finds the shortest path from start to goal using the A* …","Formats the error for display in user-facing contexts.","Formats the error for debugging purposes.","","Returns the argument unchanged.","Returns the argument unchanged.","Calls <code>U::from(self)</code>.","Calls <code>U::from(self)</code>.","Creates a new <code>AStar</code> instance with the provided nodes.","","","","","","","","Directions used in nodes.","","Represents a node on a map.","","","","","","","","","","","","","","","","","","","","","Returns the argument unchanged.","Returns the argument unchanged.","Returns a vector of directions where neighbors are present.","Converts a 2D grid into <code>Node</code> objects.","","","Calls <code>U::from(self)</code>.","Calls <code>U::from(self)</code>.","","","Creates a new <code>Node</code> and initializes neighbors for the four …","","Prints a 2D grid and an optional path to the screen.","Removes the neighbor for a specific direction.","Sets whether the node is blocked or not.","Sets the neighbor position for a specific direction.","","","","","","","","","","","Priority queue used in the A* algorithm.","Represents the states used in the A* algorithm.","","","","","","","Defines the ordering for <code>State</code>, ensuring that states with …","","","","","Returns the argument unchanged.","Returns the argument unchanged.","Calls <code>U::from(self)</code>.","Calls <code>U::from(self)</code>.","Checks if the queue is empty.","Creates a new, empty <code>PriorityQueue</code>.","Provides partial ordering for <code>State</code>.","Removes and returns the <code>State</code> with the highest priority …","","Adds a new <code>State</code> to the queue.","","","","","","",""],"i":[0,0,0,0,0,0,0,0,0,0,0,6,6,6,6,6,1,6,1,1,6,6,1,6,1,6,1,1,6,6,1,6,1,6,1,0,14,0,14,14,14,14,14,14,14,14,10,14,10,14,10,14,10,14,14,10,14,10,14,10,10,10,14,10,14,10,10,10,10,14,10,10,10,10,14,10,14,10,14,10,14,10,10,10,0,0,21,22,21,22,21,21,21,21,21,21,22,21,22,21,22,22,22,21,22,21,22,21,21,22,21,22,21,22],"f":"```````````````{ce{}{}}000{{b{f{dd}}{f{dd}}}{{n{{j{{h{{f{dd}}}}}}l}}}}{{lA`}Ab}0{{bA`}Ab}{cc{}}044{{{Af{{f{dd}}Ad}}}b}{cAh{}}{c{{n{e}}}{}{}}000{cAj{}}0``````````8888{AlAl}{AdAd}{{ce}An{}{}}0{{AlAl}B`}{{AlAl}Bb}{{AdAd}Bb}{{AlA`}Ab}{{AdA`}Ab}<<{Ad{{h{Al}}}}{{{Bf{{h{Bd}}}}}{{Af{{f{dd}}Ad}}}}{{Alc}AnBh}{{Adc}AnBh}{ce{}{}}0``{{ddBbdd}Ad}{{AlAl}{{j{B`}}}}{{{Bf{{h{Bd}}}}{j{{h{{f{dd}}}}}}}An}{{AdAl}An}{{AdBb}An}{{AdAl{j{{f{dd}}}}}An}66{c{{n{e}}}{}{}}000{cAj{}}0````8888{BjBj}{{ce}An{}{}}{{BjBj}B`}`{{BjBj}Bb}{{BjA`}Ab}{{BlA`}Ab}{cc{}}0??{BlBb}{{}Bl}{{BjBj}{{j{B`}}}}{Bl{{j{Bj}}}}`{{BlBj}An}{ce{}{}}>>>>==","c":[],"p":[[5,"AStar",9],[1,"usize"],[1,"tuple"],[5,"Vec",114],[6,"Option",115],[6,"AStarError",9],[6,"Result",116],[5,"Formatter",117],[8,"Result",117],[5,"Node",35],[5,"HashMap",118],[5,"String",119],[5,"TypeId",120],[6,"Direction",35],[1,"unit"],[6,"Ordering",121],[1,"bool"],[1,"i32"],[1,"slice"],[10,"Hasher",122],[5,"State",84],[5,"PriorityQueue",84]],"b":[[20,"impl-Display-for-AStarError"],[21,"impl-Debug-for-AStarError"]]}],\
["example",{"doc":"A* Pathfinding Example","t":"","n":[],"q":[],"d":[],"i":[],"f":"","c":[],"p":[],"b":[]}]\
]'));
if (typeof exports !== 'undefined') exports.searchIndex = searchIndex;
else if (window.initSearch) window.initSearch(searchIndex);
